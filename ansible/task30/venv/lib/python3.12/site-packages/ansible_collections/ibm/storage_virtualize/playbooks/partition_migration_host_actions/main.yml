---
- name: Using Storage Virtualize collection to monitor partition migrating from one system to another.
  hosts: flash_systems
  gather_facts: false
  connection: local
  vars_files:
    - vars.yml
  vars:
    are_all_hosts_in_inventory: true
    commit_flag: true
  serial: 1
  tasks:

      ####################################
      # Check for migration
      ####################################

    - name: Gather lspartition information from flashsystem.
      ibm.storage_virtualize.ibm_svcinfo_command:
        clustername: "{{ ansible_host }}"
        username: "{{ ansible_user }}"
        password: "{{ ansible_password }}"
        command: "lspartition -gui -json"
        log_path: "{{ logpath }}"
      register: partition_info
      when: "'flash_systems' in group_names"

    - name: Clean the lspartition output
      ansible.builtin.set_fact:
        lspartition_output: "{{ (partition_info.stdout | join('') | from_json) | flatten(1) }}"

    - name: Set deployment_type based on input value
      ansible.builtin.set_fact:
        deployment_type: "{{ 'single_host_migre' if deployment_type == 1 else 'multi_host_migre' if deployment_type == 2 else deployment_type }}"
      when: deployment_type in [1, 2]


      ####################################
      # Fetch Data for host identification
      ####################################

    - name: Fetch Data for host identification.
      when: (lspartition_output | selectattr('migration_status', 'equalto', 'awaiting_user_input') | list | length) > 0
      block:

        - name: Fetch enclosure serial number
          ibm.storage_virtualize.ibm_svc_info:
            gather_subset: "node"
            clustername: "{{ ansible_host }}"
            username: "{{ ansible_user }}"
            password: "{{ ansible_password }}"
          register: enclosure_serial_number

        - name: Set facts for getting data about migrating partition and enclosure serial no.
          ansible.builtin.set_fact:
            migrating_partition: "{{ lspartition_output | selectattr('migration_status', 'equalto', 'awaiting_user_input') }}"
            enclosure_serial_number_out: "{{ enclosure_serial_number.Node[0]['enclosure_serial_number'] }}"

        - name: Set facts for partition name.
          ansible.builtin.set_fact:
            partition_name: "{{ migrating_partition[0]['name'] }}"

        - name: Gather lshost information from flashsystem.
          ibm.storage_virtualize.ibm_svc_info:
            clustername: "{{ ansible_host }}"
            username: "{{ ansible_user }}"
            password: "{{ ansible_password }}"
            log_path: "{{ logpath }}"
            gather_subset: "host"
            filtervalue: 'partition_name={{ partition_name }}'
          register: lshost_output
          changed_when: false

        - name: Gather details of each host on flashsystem.
          ibm.storage_virtualize.ibm_svc_info:
            gather_subset: "host"
            clustername: "{{ ansible_host }}"
            username: "{{ ansible_user }}"
            password: "{{ ansible_password }}"
            objectname: "{{ item.id }}"
            log_path: "{{ logpath }}"
          changed_when: false
          register: shared_targetports_output
          loop: "{{ lshost_output.Host }}"

        - name: Initialize extracted_hosts list.
          ansible.builtin.set_fact:
            extracted_hosts: []
            extracted_hosts_tmp: []

        - name: Extract relevant fc host data for the identified partition.
          ansible.builtin.set_fact:
            extracted_hosts: >-
              {{
                extracted_hosts | combine({
                  item.Host.id | int: {
                    "inventory_hostname": inventory_hostname,
                    "name": item.Host.name,
                    "wwpns": item.Host.nodes | default([]) | map(attribute='WWPN') | list,
                    "partition": item.Host.partition_name | default(""),
                    "type": "FC"
                  }
                })
              }}
          loop: "{{ shared_targetports_output.results }}"
          when: item.Host is not none and item.Host.nodes[0].WWPN is defined

        - name: Extract relevant iSCSI host data for the identified partition.
          ansible.builtin.set_fact:
            extracted_hosts: >-
              {{
                extracted_hosts | combine({
                  item.Host.id | int: {
                    "inventory_hostname": inventory_hostname,
                    "name": item.Host.name,
                    "iscsi_name": item.Host.nodes | default([]) | map(attribute='iscsi_name') | list,
                    "partition": item.Host.partition_name | default(""),
                    "portset_name":item.Host.portset_name,
                    "type": 'iscsi'
                  }
                })
              }}
          loop: "{{ shared_targetports_output.results }}"
          when: item.Host is not none and item.Host.nodes[0].iscsi_name is defined

        - name: Gather lsportset information from flashsystem.
          ibm.storage_virtualize.ibm_svc_info:
            gather_subset: "portset"
            clustername: "{{ ansible_host }}"
            username: "{{ ansible_user }}"
            password: "{{ ansible_password }}"
            objectname: "{{ item.value.portset_name }}"
            log_path: "{{ logpath }}"
          changed_when: false
          register: portset_info
          loop: "{{ extracted_hosts | dict2items }}"
          when: item.value.type == 'iscsi'

        - name: Build host entries for extracted_hosts
          ansible.builtin.set_fact:
            extracted_hosts_tmp: >-
              {{
                extracted_hosts_tmp | default([]) + [
                  {
                    (item.item.key | string): (
                      item.item.value | combine(
                        (
                          {'replication_portset_link_uid': item.Portset.replication_portset_link_uid}
                          if item.item.value.type == 'iscsi'
                          else {}
                        )
                      )
                    )
                  }
                ]
              }}
          loop: "{{ portset_info.results }}"
          when: item.item is defined and item.item.value is defined

        - name: Combine extracted_hosts_tmp into a single dict
          ansible.builtin.set_fact:
            extracted_hosts: "{{ extracted_hosts_tmp | default([]) | combine }}"

        - name: Process extracted host data if not empty.
          when: extracted_hosts != []
          block:

            - name: Gather lsip information from flashsystem.
              ibm.storage_virtualize.ibm_svcinfo_command:
                clustername: "{{ ansible_host }}"
                username: "{{ ansible_user }}"
                password: "{{ ansible_password }}"
                command: "lsip -json"
                log_path: "{{ logpath }}"
              register: ip_info

            - name: Convert raw ip_info.stdout string to structured data
              ansible.builtin.set_fact:
                ip_info_parsed: "{{ ip_info.stdout | from_json }}"

            - name: Add iscsi_ips to extracted_hosts
              ansible.builtin.set_fact:
                extracted_hosts: >-
                  {%- set updated_hosts = {} -%}
                  {%- for key, host in extracted_hosts.items() -%}
                    {%- set _host = host.copy() -%}
                    {%- if 'type' in _host and _host['type'] == 'iscsi' and 'portset_name' in _host -%}
                      {%- set ips = [] -%}
                      {%- for ip in ip_info_parsed -%}
                        {%- if 'portset_name' in ip and
                                (ip['portset_name'] | string | lower | trim) == (_host['portset_name'] | string | lower | trim) and
                                'IP_address' in ip -%}
                          {%- set _ = ips.append(ip['IP_address']) -%}
                        {%- endif -%}
                      {%- endfor -%}
                      {%- set _ = _host.update({'iscsi_ips': ips}) -%}
                    {%- endif -%}
                    {%- set _ = updated_hosts.update({ key: _host }) -%}
                  {%- endfor -%}
                  {{ updated_hosts }}

            - name: Create path to save tmp
              ansible.builtin.set_fact:
                file_path: "{{ temp_file_location }}/one_click_migration_{{ enclosure_serial_number_out }}"

            - name: Ensure temporary folder exists
              ansible.builtin.file:
                path: "{{ file_path }}"
                state: directory
                mode: '0755'
              delegate_to: localhost

            - name: Find all files in the temporary folder
              ansible.builtin.find:
                paths: "{{ file_path }}"
              register: temp_files
              delegate_to: localhost

            - name: Remove all files in the temporary folder
              ansible.builtin.file:
                path: "{{ item.path }}"
                state: absent
              loop: "{{ temp_files.files }}"

            - name: Write extracted_hosts information to file.
              ansible.builtin.copy:
                content: "{{ extracted_hosts | to_nice_json }}"
                dest: "{{ file_path }}/svc_host_obj_list_present.json"
                mode: '0600'
              delegate_to: localhost

            - name: Call Host_identification playbook to fetch list of host mapped to flashsystem.
              ansible.builtin.command:
                cmd: >
                  ansible-playbook host_identification.yml
                  -i {{ inventory_file }}
                  -e 'file_name={{ file_path }}
                  json_file=svc_host_obj_list_present.json
                  location_flag=target'
              changed_when: false

            - name: Check if file directory exists
              ansible.builtin.stat:
                path: "{{ file_path }}/matched_hosts.json"
              register: matched_host_dir

            - name: End play if condition not met
              ansible.builtin.meta: end_play
              when: not matched_host_dir.stat.exists

            - name: Read data provided by host_identification.yml playbook from file.
              ansible.builtin.slurp:
                src: "{{ file_path }}/matched_hosts.json"
              register: host_matched_list
              delegate_to: localhost

            - name: Parse host_matched_list to read content.
              ansible.builtin.set_fact:
                host_matched_list_processed: "{{ host_matched_list['content'] | b64decode | from_json }}"

            - name: Set facts for matched hosts and types
              ansible.builtin.set_fact:
                host_matched_inventory_hosts: "{{ host_matched_list_processed | map(attribute='inventory_hostname') | list }}"
                host_matched_hosts_type: "{{ host_matched_list_processed | map(attribute='host_type') | list }}"
                is_windows_host: "{{ 'Win32NT' in (host_matched_list_processed | map(attribute='host_type') | list) }}"
                is_esxi_host: "{{ 'VMkernel' in (host_matched_list_processed | map(attribute='host_type') | list) }}"
                extracted_hosts_length: "{{ extracted_hosts.keys() | length }}"

            - name: Set single host flag for migration
              ansible.builtin.set_fact:
                single_host_present_flag: "{{ (extracted_hosts_length | int == 1 and deployment_type == 'single_host_migre') | bool }}"

            - name: Is host are same from inventory and from svc host
              when: deployment_type == "multi_host_migre"
              block:

                - name: Extract all inventory hosts list for inventory file
                  ansible.builtin.set_fact:
                    inventory_hosts: "{{ groups[hosts_name] | list }}"

                - name: Extract host which are not present in inventory file
                  ansible.builtin.set_fact:
                    host_not_in_inventory: "{{ host_matched_inventory_hosts | intersect(inventory_hosts) }}"

                - name: Extract length of host which are not present in inventory file
                  ansible.builtin.set_fact:
                    host_not_in_inventory_length: "{{ host_not_in_inventory | length }}"

                - name: Set facts for flags
                  ansible.builtin.set_fact:
                    are_all_hosts_in_inventory: "{{ true if extracted_hosts_length == host_not_in_inventory_length else false }}"

                - name: Print the matched hosts
                  ansible.builtin.debug:
                    msg: "Host assign to partition: {{ host_not_in_inventory }}"


      ####################################
      # Host rescan action
      ####################################

    - name: Host rescan action if host_rescan_requested event raised.
      when: (lspartition_output | selectattr('user_action_type', 'equalto', 'host_rescan_requested') | list | length) > 0
      block:

        - name: Check extracted_hosts is empty.
          when: extracted_hosts != []
          block:

            - name: Extract FC inventory hostname
              ansible.builtin.set_fact:
                fc_hosts: "{{ host_matched_list_processed | selectattr('connection', 'equalto', 'FC') | map(attribute='inventory_hostname') | list }}"

            - name: Extract iSCSI inventory hostname
              ansible.builtin.set_fact:
                iscsi_hosts: "{{ host_matched_list_processed | selectattr('connection', 'equalto', 'iscsi') | map(attribute='inventory_hostname') | list }}"

            - name: Call rescan playbook based on hosts discovery status.
              ansible.builtin.command:
                cmd: "ansible-playbook rescan_multipath_devices.yml -i {{ inventory_file }} -e 'file_name={{ file_path }}'"
              changed_when: false
              when: (lspartition_output | selectattr('hosts_discovery_status', 'equalto', 'need_rescan') | list | length) > 0 and fc_hosts | length != 0

            - name: Call discovery playbook based on hosts discovery status.
              ansible.builtin.command:
                cmd: "ansible-playbook discover_multipath_devices.yml -i {{ inventory_file }} -e 'file_name={{ file_path }} rescan_flag=no'"
              changed_when: false
              when: (lspartition_output | selectattr('hosts_discovery_status', 'equalto', 'need_rescan') | list | length) > 0 and iscsi_hosts | length != 0

            - name: Waiting for IO to stabilize.
              ansible.builtin.wait_for:
                timeout: "{{ io_stability_time | int }}"
              when: (lspartition_output | selectattr('hosts_discovery_status', 'equalto', 'need_rescan') | list | length) > 0

            - name: Run lspartition on flashsystem to verify the host discovery status.
              ibm.storage_virtualize.ibm_svcinfo_command:
                clustername: "{{ ansible_host }}"
                username: "{{ ansible_user }}"
                password: "{{ ansible_password }}"
                command: "lspartition -gui -json {{ partition_name }}"
                log_path: "{{ logpath }}"
              register: partition_in_progress_info

            - name: Clean the lspartition output.
              ansible.builtin.set_fact:
                partition_in_progress_info_output: "{{ (partition_in_progress_info.stdout | from_json) }}"

            - name: Rescan triggered up to 5 times.
              when: partition_in_progress_info_output['hosts_discovery_status'] != 'ready'
              block:
                - name: Read data provided by host_identification.yml playbook from file.
                  ansible.builtin.slurp:
                    src: "{{ file_path }}/matched_hosts.json"
                  register: host_matched_list
                  delegate_to: localhost

                - name: Parse host_matched_list to read content.
                  ansible.builtin.set_fact:
                    host_matched_list_processed: "{{ host_matched_list['content'] | b64decode | from_json }}"

                  # running it for 5 times
                - name: Check hosts_discovery_status and run rescan task 1.
                  ansible.builtin.import_tasks: test_and_rescan_hosts.yml

                - name: Check hosts_discovery_status and run rescan task 2.
                  ansible.builtin.import_tasks: test_and_rescan_hosts.yml
                  when: partition_in_progress_info_output_1['hosts_discovery_status'] != 'ready'

                - name: Check hosts_discovery_status and run rescan task 3.
                  ansible.builtin.import_tasks: test_and_rescan_hosts.yml
                  when: partition_in_progress_info_output_1['hosts_discovery_status'] != 'ready'

                - name: Check hosts_discovery_status and run rescan task 4.
                  ansible.builtin.import_tasks: test_and_rescan_hosts.yml
                  when: partition_in_progress_info_output_1['hosts_discovery_status'] != 'ready'

                - name: Check hosts_discovery_status and run rescan task 5.
                  ansible.builtin.import_tasks: test_and_rescan_hosts.yml
                  when: partition_in_progress_info_output_1['hosts_discovery_status'] != 'ready'

        - name: Fix the host rescan request event (host_rescan_requested) if hosts discovery status is ready.
          ibm.storage_virtualize.ibm_sv_manage_storage_partition:
            clustername: "{{ ansible_host }}"
            username: "{{ ansible_user }}"
            password: "{{ ansible_password }}"
            name: "{{ partition_name }}"
            migrationaction: fixeventwithchecks
            state: present
            log_path: "{{ logpath }}"
          when: partition_in_progress_info_output['hosts_discovery_status'] == 'ready'


      ####################################
      # Commit migrating action
      ####################################

    - name: Commit migrating when commit_or_rollback event raised.
      when: (lspartition_output | selectattr('user_action_type', 'equalto', 'commit_or_rollback') | list | length) > 0
      block:

        - name: Validate multipath on target system.
          when: extracted_hosts != [] and min_active_path != 0 and not is_windows_host and not is_esxi_host
          block:

            - name: Fetch WWNN for Target system.
              ibm.storage_virtualize.ibm_svc_info:
                gather_subset: "node"
                clustername: "{{ ansible_host }}"
                username: "{{ ansible_user }}"
                password: "{{ ansible_password }}"
                log_path: "{{ logpath }}"
              register: targetportfc_tgt

            - name: Set fact for lsnode for Target system.
              ansible.builtin.set_fact:
                targetports_data_tgt: "{{ targetportfc_tgt.Node }}"

            - name: Initialize empty dictionary for Target system.
              ansible.builtin.set_fact:
                targetports_output_tgt: {}

            - name: Extract relevant data for Target system.
              ansible.builtin.set_fact:
                targetports_output_tgt: >-
                  {{
                    targetports_output_tgt | combine({
                      item.id | int: {
                        "name": item.name,
                        "WWNN": item.WWNN,
                        "iscsi_name": item.iscsi_name,
                      }
                    })
                  }}
              loop: "{{ targetports_data_tgt }}"
              when: item is not none

            - name: Write extracted data to file to send to verify_multipath_devices playbook.
              delegate_to: localhost
              ansible.builtin.copy:
                content: "{{ targetports_output_tgt | to_nice_json }}"
                dest: "{{ file_path }}/vmd_output.json"
                mode: '0600'

            - name: Call verify multipath devices playbook.
              ansible.builtin.command:
                cmd: "ansible-playbook verify_multipath_devices.yml -i {{ inventory_file }} -e 'file_name={{ file_path }}'"
              changed_when: false

            - name: Read output data generated by verify_multipath_devices playbook.
              ansible.builtin.slurp:
                src: "{{ file_path }}/vmd_output_final_out.json"
              register: json_data

            - name: Parse JSON.
              ansible.builtin.set_fact:
                parsed_data: "{{ json_data['content'] | b64decode | from_json }}"

            - name: Set commit flag based on min_active_path.
              ansible.builtin.set_fact:
                non_compliant_names: "{{ parsed_data['data'] | selectattr('non_compliant_devices', 'ne', []) |
                  map(attribute='active_paths_on_tgt.inventory_name') | list }}"

            - name: Set commit flag based on min_active_path.
              ansible.builtin.set_fact:
                commit_flag: false
              when: non_compliant_names | length > 0

            - name: Print non-compliant inventory names.
              ansible.builtin.debug:
                msg: "{{ non_compliant_names | map('regex_replace', '^(.*)$', '\\1 does not meet the requirement') | list }}"
              when: non_compliant_names | length > 0

            - name: Over write the single_host_present_flag flag if deployment_type is multi_host_migre
              ansible.builtin.set_fact:
                single_host_present_flag: true
              when: deployment_type == "multi_host_migre"

            - name: Print commit flags.
              ansible.builtin.debug:
                msg:
                  - "commit_flag is set to {{ commit_flag }}"
                  - "are_all_hosts_in_inventory {{ are_all_hosts_in_inventory }}"
                  - "single_host_present_flag {{ single_host_present_flag }}"
                  - "extracted_hosts_length {{ extracted_hosts_length }}"
                  - "deployment_type {{ deployment_type }}"

            - name: Commit and logout block
              when: commit_flag and are_all_hosts_in_inventory and single_host_present_flag
              block:

                - name: Set facts for partition name.
                  ansible.builtin.set_fact:
                    partition_name: "{{ migrating_partition[0]['name'] }}"

                - name: Run lspartition on flashsystem to source cluster information.
                  ibm.storage_virtualize.ibm_svcinfo_command:
                    clustername: "{{ ansible_host }}"
                    username: "{{ ansible_user }}"
                    password: "{{ ansible_password }}"
                    command: "lspartition -gui -json {{ partition_name }}"
                    log_path: "{{ logpath }}"
                  register: partition_in_progress_info

                - name: Clean the lspartition output.
                  ansible.builtin.set_fact:
                    partition_in_progress_info_output: "{{ (partition_in_progress_info.stdout | from_json) }}"

                - name: Fetch cluster IP for source system.
                  ibm.storage_virtualize.ibm_svc_info:
                    gather_subset: "partnership"
                    clustername: "{{ ansible_host }}"
                    username: "{{ ansible_user }}"
                    password: "{{ ansible_password }}"
                    objectname: "{{ partition_in_progress_info_output['location1_system_id'] }}"
                    log_path: "{{ logpath }}"
                  register: partnership_info

                - name: Cleaning up ip addr
                  ansible.builtin.set_fact:
                    ip_only: "{{  partnership_info.Partnership['console_IP'].split(':')[0] }}"

                - name: Find matching hostname for the user-provided IP   # # noqa run-once[task]
                  ansible.builtin.set_fact:
                    matched_host: "{{ item }}"
                  loop: "{{ groups['flash_systems'] }}"
                  when: hostvars[item].ansible_host == ip_only
                  run_once: true

                - name: Source side ip logout block
                  when: matched_host is defined and matched_host | length != 0
                  block:

                    - name: Setting up source credential
                      ansible.builtin.set_fact:
                        source_ansible_host: "{{ hostvars[matched_host]['ansible_host'] }}"
                        source_ansible_user: "{{ hostvars[matched_host]['ansible_user'] }}"
                        source_ansible_password: "{{ hostvars[matched_host]['ansible_password'] }}"
                      delegate_to: "{{ matched_host | default('localhost') }}"

                    - name: Setting up source credential safely
                      ansible.builtin.set_fact:
                        source_ansible_host: "{{ hostvars[matched_host | default('')]['ansible_host'] | default('') }}"
                        source_ansible_user: "{{ hostvars[matched_host | default('')]['ansible_user'] | default('') }}"
                        source_ansible_password: "{{ hostvars[matched_host | default('')]['ansible_password'] | default('') }}"
                      when: matched_host is defined and matched_host in hostvars

                    - name: Gather lshost information from flashsystem.
                      ibm.storage_virtualize.ibm_svc_info:
                        clustername: "{{ source_ansible_host }}"
                        username: "{{ source_ansible_user }}"
                        password: "{{ source_ansible_password }}"
                        log_path: "{{ logpath }}"
                        gather_subset: "host"
                        filtervalue: 'partition_name={{ partition_name }}'
                      register: lshost_output
                      changed_when: false

                    - name: Gather details of each host on flashsystem.
                      ibm.storage_virtualize.ibm_svc_info:
                        gather_subset: "host"
                        clustername: "{{ source_ansible_host }}"
                        username: "{{ source_ansible_user }}"
                        password: "{{ source_ansible_password }}"
                        objectname: "{{ item.id }}"
                        log_path: "{{ logpath }}"
                      changed_when: false
                      register: shared_targetports_output
                      loop: "{{ lshost_output.Host }}"

                    - name: Initialize extracted_hosts_form_source list.
                      ansible.builtin.set_fact:
                        extracted_hosts_form_source: {}
                        extracted_hosts_form_source_tmp: []

                    - name: Extract relevant iscsi host data for the identified partition for extracted_hosts_form_source.
                      ansible.builtin.set_fact:
                        extracted_hosts_form_source: >-
                          {{
                            extracted_hosts_form_source | combine({
                              item.Host.id | int: {
                                "inventory_hostname": inventory_hostname,
                                "name": item.Host.name,
                                "iscsi_name": item.Host.nodes | default([]) | map(attribute='iscsi_name') | list,
                                "partition": item.Host.partition_name | default(""),
                                "portset_name":item.Host.portset_name,
                                "type": 'iscsi'
                              }
                            })
                          }}
                      loop: "{{ shared_targetports_output.results }}"
                      when: item.Host is not none and item.Host.nodes[0].iscsi_name is defined

                    - name: Process extracted host data if not empty.
                      when: extracted_hosts_form_source | length != 0
                      block:

                        - name: Gather lsportset information from flashsystem.
                          ibm.storage_virtualize.ibm_svc_info:
                            gather_subset: "portset"
                            clustername: "{{ source_ansible_host }}"
                            username: "{{ source_ansible_user }}"
                            password: "{{ source_ansible_password }}"
                            objectname: "{{ item.value.portset_name }}"
                            log_path: "{{ logpath }}"
                          changed_when: false
                          register: portset_info
                          loop: "{{ extracted_hosts_form_source | dict2items }}"
                          when: item.value.type == 'iscsi'

                        - name: Build host entries for extracted_hosts_form_source
                          ansible.builtin.set_fact:
                            extracted_hosts_form_source_tmp: >-
                              {{
                                extracted_hosts_form_source_tmp | default([]) + [
                                  {
                                    (item.item.key | string): (
                                      item.item.value | combine(
                                        (
                                          {'replication_portset_link_uid': item.Portset.replication_portset_link_uid}
                                          if item.item.value.type == 'iscsi'
                                          else {}
                                        )
                                      )
                                    )
                                  }
                                ]
                              }}
                          loop: "{{ portset_info.results }}"
                          when: item.item is defined and item.item.value is defined

                        - name: Combine extracted_hosts_form_source into a single dict
                          ansible.builtin.set_fact:
                            extracted_hosts_form_source: "{{ extracted_hosts_form_source_tmp | default([]) | combine }}"

                        - name: Gather lsip information from flashsystem.
                          ibm.storage_virtualize.ibm_svcinfo_command:
                            clustername: "{{ source_ansible_host }}"
                            username: "{{ source_ansible_user }}"
                            password: "{{ source_ansible_password }}"
                            command: "lsip -json"
                            log_path: "{{ logpath }}"
                          register: ip_info

                        - name: Convert raw ip_info.stdout string to structured data
                          ansible.builtin.set_fact:
                            ip_info_parsed: "{{ ip_info.stdout | from_json }}"

                        - name: Add iscsi_ips to extracted_hosts
                          ansible.builtin.set_fact:
                            extracted_hosts_form_source: >-
                              {%- set updated_hosts = {} -%}
                              {%- for key, host in extracted_hosts_form_source .items() -%}
                                {%- set _host = host.copy() -%}
                                {%- if 'type' in _host and _host['type'] == 'iscsi' and 'portset_name' in _host -%}
                                  {%- set ips = [] -%}
                                  {%- for ip in ip_info_parsed -%}
                                    {%- if 'portset_name' in ip and
                                            (ip['portset_name'] | string | lower | trim) == (_host['portset_name'] | string | lower | trim) and
                                            'IP_address' in ip -%}
                                      {%- set _ = ips.append(ip['IP_address']) -%}
                                    {%- endif -%}
                                  {%- endfor -%}
                                  {%- set _ = _host.update({'iscsi_ips': ips}) -%}
                                {%- endif -%}
                                {%- set _ = updated_hosts.update({ key: _host }) -%}
                              {%- endfor -%}
                              {{ updated_hosts }}

                        - name: Write extracted_hosts_form_source  information to file.
                          ansible.builtin.copy:
                            content: "{{ extracted_hosts_form_source | to_nice_json }}"
                            dest: "{{ file_path }}/svc_host_obj_list_present_source.json"
                            mode: '0600'
                          delegate_to: localhost

                        - name: Call Host_identification playbook to fetch list of host mapped to flashsystem.
                          ansible.builtin.command:
                            cmd: >
                              ansible-playbook host_identification.yml
                              -i {{ inventory_file }}
                              -e 'file_name={{ file_path }}
                              json_file=svc_host_obj_list_present_source.json
                              location_flag=source'
                          changed_when: false

                - name: Complete migration (on target system) by running migration action.
                  ibm.storage_virtualize.ibm_sv_manage_storage_partition:
                    clustername: "{{ ansible_host }}"
                    username: "{{ ansible_user }}"
                    password: "{{ ansible_password }}"
                    name: "{{ partition_name }}"
                    migrationaction: fixeventwithchecks
                    state: present
                    log_path: "{{ logpath }}"
                  when: matched_host is defined and matched_host | length != 0

                - name: Wait for either migration_status = "" to complete the migration
                  ibm.storage_virtualize.ibm_svc_info:
                    clustername: "{{ ansible_host }}"
                    username: "{{ ansible_user }}"
                    password: "{{ ansible_password }}"
                    gather_subset: partition
                    objectname: "{{ partition_name }}"
                  register: lspartition_out
                  until: lspartition_out.Partition['migration_status'] == ''
                  retries: 60
                  delay: 30

                - name: Call iscsi_logout playbook to logout
                  ansible.builtin.command:
                    cmd: "ansible-playbook iscsi_logout.yml -i {{ inventory_file }} -e 'file_name={{ file_path }}'"
                  changed_when: false
                  when:
                    - matched_host is defined
                    - matched_host | length > 0
                    - extracted_hosts_form_source is defined
                    - extracted_hosts_form_source | length > 0
